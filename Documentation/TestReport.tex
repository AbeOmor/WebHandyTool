\documentclass[12pt, titlepage]{article}
\usepackage{xcolor} % for different colour comments
\usepackage[left=15mm,right=15mm,top=1in,bottom=1in]{geometry}
\usepackage{framed}
\usepackage{graphicx}
\usepackage{float}
\graphicspath{ {images/} }
%% Comments
\newif\ifcomments\commentsfalse %i replaced comments true by comment false so the comments will be hidden

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{magenta}{SS}{#1}}
\newcommand{\hm}[1]{\authornote{blue}{HM}{#1}} %Hediyeh
\newcommand{\tz}[1]{\authornote{blue}{TZ}{#1}} %Tahereh
\newcommand{\pl}[1]{\authornote{blue}{PL}{#1}} %Peng

\begin{document}
\title{pylinkvalidator \\
 Test Report : newAGEtech, Group H }
\author{Genevieve Okon (Okong), Abraham Omorogbe(Omorogoa),\\
 Eric Le Forti(Leforte)}
\date{\today}
\maketitle

\tableofcontents
\listoftables
\listoffigures
\pagebreak

\begin{center}\textbf{Revision History}\end{center}
\begin{table}[h!]
\centering
	\begin{tabular}{| p{1.5cm} | p{2.5cm} | p{7cm} |p{3cm} |}    \hline
	Revision  &Revision Date &Description of Change &Author\\ \hline
	1& 20-10-15 &Initiate Test Plan Document  and Introduction&Eric Le Fort\\ \hline
	2&26-11-2015&Finalize Outline & Abraham Omorogbe\\ \hline	
3&26-11-2015&Functional system tests& Abraham Omorogbe\\ \hline
4&26-11-2015&Functional system tests& Eric Le Fort\\ \hline
5&26-11-2015&Non-Functional system tests& Eric Le Fort\\ \hline
6 &26-11-2015&Usability Testing & Eric Le Fort\\ \hline
7& 26-11-2015& Requirements Traceability & Eric Le Fort\\ \hline
8& 27-11-2015 &Testing Summary& Genevieve Okon\\ \hline
9& 27-11-2015 &Code Coverage& Genevieve Okon\\ \hline

	
       \end{tabular}
       \caption{Revision History}
       \label{table:Revision History}
\end{table}





\section{Introduction}
\subsection{Objective}
The purpose of this report is to specify the methodology of testing to be used for Pylinkvalidator in detail. Every test case will be accompanied by a short description to convey the reason each test was written as well as a breakdown of expected results as well as whether those results were achieved or not. Following that section the document will trace the tests back to the requirements and then provide a more general summary of the results of testing.

\subsection{Approach}
The methodology to be used for testing will involve a succinct set of tests to prove each requirement is fully functional and performing at an acceptable level. These tests will cover white-boxed boundary cases, cases dealing with extremes as well as standard cases.\\

Certain tests, such as those concerning usability or involving acquiring user input, are tested much more straightforwardly using manual methods. Therefore, these sorts of tests will be performed in a manual manner. All other tests will be conducted using automated testing utilizing a testing suite known as PyUnit.

\subsection{Tables of Acronyms, Abbreviations \& Definitions}

\begin{table}[h!]
\centering
\begin{tabular}{| p{3cm} | p{10cm} |}    \hline
	Term &Meaning\\ \hline
	html & Hypertext Markup Language\\ \hline
\end{tabular}
\caption{Acronyms \& Abbreviations}
\label{table:Acronyms and Abbreviations}
\end{table}

\begin{table}[h!]
\centering
\begin{tabular}{| p{3cm} | p{10cm} |}    \hline
	Term &Definition\\ \hline
	PyUnit &A widely accepted testing suite to be used with the Python programming language.\\ \hline
	\{$\emptyset$\} &Denotes an empty set, not to be confused with \{0\} which is a set containing only 0.\\ \hline
	Beautiful Soup &An existing framework that breaks a webpage down into its components.\\ \hline
	HTML Error Code &A three digit number that corresponds to various states of a website.
\end{tabular}
\caption{Definitions}
\label{table:Definitions}
\end{table}



\section{Functional System Tests}
\subsection{F1: Exact String Searching}
\textbf{Process:}
\begin{enumerate}
\item{Receive String to be parsed through and a query to search for.}
\item{Search through that String for the query.}
\item{Check that the results of the search match those that should be returned.}
\end{enumerate}
~\\
The queries used for each input String will be as follows:
\begin{itemize}
\item{hello}
\item{LASDGLKGSVLIUGAEOUGSVLUHwe;ofrw.k?bwri;hqf.IBA LIU GqleiugwKUGwrliugwrgOUGFW	;OURW;U}
\item{Eric}
\item{my name is Eric!}
\item{my name is Eric}
\end{itemize}
~\\
The input Strings used will be as follows:
\begin{enumerate}
\item{"Hello world!"}
\item{""}
\item{"Hello. My name is Eric. I am writing this simple test to check to see how well my parsing algorithm is performing. hello again, don't forget my name: Eric. That is all."}
\end{enumerate}
\begin{table}[h!]
\centering
\begin{tabular}{ p{7cm}  p{4cm}  p{4cm} }
	Input &Expected Result &Actual Result\\\\ \hline
	1 &\{0\}  &\{0\}\\ 
	~ &\{$\emptyset$\} &\{$\emptyset$\}\\
	~ &\{$\emptyset$\} &\{$\emptyset$\}\\
	~ &\{$\emptyset$\} &\{$\emptyset$\}\\
	~ &\{$\emptyset$\} &\{$\emptyset$\}\\ \hline
	2 &\{$\emptyset$\} &\{$\emptyset$\}\\ 
	~ &\{$\emptyset$\} &\{$\emptyset$\}\\
	~ &\{$\emptyset$\} &\{$\emptyset$\}\\
	~ &\{$\emptyset$\} &\{$\emptyset$\}\\
	~ &\{$\emptyset$\} &\{$\emptyset$\}\\ \hline
	3 &\{0, 114\}  &\{0, 114\}\\ 
	~ &\{$\emptyset$\} &\{$\emptyset$\}\\
	~ &\{18, 149\} &\{18, 149\}\\
	~ &\{$\emptyset$\} &\{$\emptyset$\}\\
	~ &\{7\} &\{7\}\\ \hline
\end{tabular}
\caption{F1 Tests}
\label{table:F1 Tests}
\end{table}

\subsection{F2: Similar String Searching}
The tests that were run during F1 will be ran again in the same fashion using a proximity of 0. This forces the same functionality as performing an exact String search and so the results shall be the same as above.\\\\
\textbf{Process:}
\begin{enumerate}
\item{Receive String to be parsed through and a query to search for.}
\item{Search through that String for the query.}
\item{Check that the results of the search match those that should be returned.}
\end{enumerate}
\begin{table}[h!]
\centering
\begin{tabular}{ p{7cm}  p{4cm}  p{4cm} }{H}
	Input &Expected Result &Actual Result\\ \hline
	String: "Here comes my hero"\\
	Query: "HERE"\\
	proximity: 1 & \{0, 14\} & \{0, 14\}\\ \hline
	String: "Some text, hello"\\
	Query: "hello"\\
	proximity: 2 & \{11\} & \{11\}\\ \hline
	String: "hehhhehellp"\\
	Query: "hello"\\
	proximity: 1 & \{6\} & \{6\}\\ \hline
	String: ". \textbackslash n .. \textbackslash n q1/.SQL \textbackslash n q2.SQL \textbackslash n fileResult.txt"\\
	Query: "fileResults"\\
	proximity: 1 & \{28\} & \{28\}\\ \hline
	String: ". \textbackslash n .. \textbackslash n q1/.SQL \textbackslash n q2.SQL \textbackslash n fileResult.txt"\\
	Query: "fileResults"\\
	proximity: & \{32\} & \{$\emptyset$\}\\ \hline
\end{tabular}
\caption{F2 Test Cases}
\label{table:F2 Test Cases}
\end{table}


\pagebreak

\subsection{F3: BFS Execution}
This test will be created in an environment to effectively test depth of a BFS. The depth folder is structure in such a way the root.html, link to the 1.html and 1.html links to 2.html and 2,html links to 3.html and so on. With this structure you can test the depth 0 -5
\begin{table}[h!]
\centering
\begin{tabular}{ p{7cm}  p{4cm}  p{4cm} }{H}
	Input &Expected Results &Actual Results\\ \hline
	url: "/depth/root.html"\\
	depth: "0"\\
	&[u'root.html']& [u'root.html']\\ \hline
	url: "/depth/root.html"\\
	depth: "1"\\
	 & [u'/root.html', u'/0.html'] & [u'/root.html', u'/0.html'] \\ \hline
	url: "/depth/root.html"\\
	depth: "2"\\
	 & [u'/root.html', u'/0.html', u'/1.html'] & [u'/root.html', u'/0.html', u'/1.html']\\ \hline
	url: "/depth/root.html"\\
	depth: "3"\\
	 & [u'/root.html', u'/0.html', u'/1.html', u'/2.html'] & [u'/root.html', u'/0.html', u'/1.html', u'/2.html']\\ \hline
	url: "/depth/root.html"\\
	depth: "4"\\
	 & [u'/root.html', u'/0.html', u'/1.html', u'/2.html', u'/3.html'] & [u'/root.html', u'/0.html', u'/1.html', u'/2.html', u'/3.html']\\ \hline
	url: "/depth/root.html"\\
	depth: "5"\\
	& [u'/root.html', u'/0.html', u'/1.html', u'/2.html', u'/3.html', u'/4.html'] & [u'/root.html', u'/0.html', u'/1.html', u'/2.html', u'/3.html', u'/4.html']\\ \hline

\end{tabular}
\caption{F3 Test Cases}
\label{table:F3 Test Cases}
\end{table}

\pagebreak

\subsection{F4: Program Navigation}
\textbf{Process:}\\
This test will be conducted by manually entering each possible value the program prompts for. Once entering a number, the program shall use that option as appropriate. Values that are not within the acceptable set of options shall return a result specifying that the value entered is invalid.\\\\
\begin{table}[h!]
\centering
\begin{tabular}{ p{7cm}  p{4cm}  p{4cm} }{H}
	Input &Expected Results &Actual Results\\\\ \hline
	value: 1  &Download Resources& Download Resources\\\\ \hline
	value: 2  &Check for Errors & Check for Errors \\\\ \hline
         value: 3 & Search for Query & Search for Query \\\\ \hline
	url: "/depth/root.html"\\
	value: 4 & Just Crawl & Just Crawl \\\\ \hline
	url: "/depth/root.html"\\
	value: 100 &Incorrect input. & Incorrect input.\\\\ \hline
\end{tabular}
\caption{F4: Program Navigation}
\label{table:F4: Program Navigation}
\end{table}

\pagebreak


\subsection{F5: Grab Links}
\textbf{Process:}\\
The program is going to take all the links on any page\\\\
\begin{table}[h!]
\centering
\begin{tabular}{ p{7cm}  p{4cm}  p{4cm} }{H}
	Input &Expected Results &Actual Results\\ \hline
        input HTML: 
        ${<html>}$
    	${<body>}$
       ${ <a href="\#">Test hash</a>}$
       ${ <a name="hello">Test name</a>}$
      ${ <a href="a.html">Test A</a>}$
     ${   <a href="sub/b.html">Test B</a>}$
      ${  <a href="/c.html">Test C</a>}$
    ${    <a href="d.html">Test D</a>}$
    ${    <a href="//www.perdu.com">Test External</a>}$
    ${    </body>}$
     ${   </html>}$
	&[None, u'a.html', u'sub/b.html', u'/c.html', u'd.html', u'//www.perdu.com']& [None, u'a.html', u'sub/b.html', u'/c.html', u'd.html', u'//www.perdu.com']\\ \hline
\end{tabular}
\caption{F5 Test Cases}
\label{table:F5 Test Cases}
\end{table}
\pagebreak


\subsection{F6: HTML Correction}
\textbf{Process:}\\
The program is going to correct any url that is missing a HTTP SCHEME such as HTTP,www or the base url. So for example, if a url is just "/about", the program will append "/about" with the base url (e.g. http://www.google.ca/about"). And if a url is missing a www, or HTTP:// ,this should fix that issue.\\\\
\begin{table}[h!]
\centering
\begin{tabular}{ p{6cm}  p{8cm}  p{2cm} }{H}
	Input &Results & Status\\ \hline
	url: "www.example.com" &"http://www.example.com/" & PASS\\\\ \hline
	url: "//www.example.com" & "http://www.example.com/" & PASS\\\\ \hline
	url: "http://www.example.com" &"http://www.example.com/"& PASS\\\\ \hline
	url: "www.example.com/" & "http://www.example.com/"& PASS\\\\ \hline
	url: "//www.example.com/" & "http://www.example.com/" & PASS\\\\ \hline
	url: "http://www.example.com/" &"http://www.example.com/" & PASS\\\\ \hline
	base: "https://www.example.com /hello/index.html"\\\\
	url: "//www.example2.com/test.js" &"http://www.example2.com/test.js" & PASS\\\\ \hline
	
	base: "https://www.example.com /hello/index.html"\\\\
	url: "/hello2/test.html" & "http://www.example.com /hello2/test.html" & PASS\\\\ \hline
	base: "https://www.example.com/hello/index.html"\\\\
	url: "test.html" &"http://www.example.com/hello/test.html"& PASS\\\\ \hline
	base: "https://www.example.com/hello/index.html"\\\\
	url: "../test.html" & "https://www.example.com/test.html"& PASS\\\\ \hline

	
	
\end{tabular}
\caption{F6 Test Cases}
\label{table:F6 Test Cases}
\end{table}


\pagebreak

\subsection{F7: Error Notifications}
\textbf{Process:}\\
This test will be conducted to check errors and successes on the test html pages. Two HTML error codes that we will be testing for are a 404 error, which means the page doesn't exist, and 200, which means it exist and it is healthy and has no errors. \\\
\begin{table}[h!]
\centering
\begin{tabular}{ p{7cm}  p{4cm}  p{4cm} }
	Input &Results & Status\\ \hline
	url: "/does\_not\_exist.html" & Error code: 404  & PASS\\\\ \hline
	url: "/index.html" & Status code: 200 & PASS\\\\ \hline
\end{tabular}
\caption{F7 Test Cases}
\label{table:F7 Test Cases}
\end{table}

\section{Non-Functional Tests}
\subsection{Usability}
\textbf{U1:} A user that knows how to execute a Python application should be able to operate this program without difficulty.

\subsection{Performance}
\textbf{P1:} All String searching operations shall be completed within a second assuming the input String isn't unreasonably large.\\\\
\textbf{P2:} Grabbing links from a page using Beautiful Soup shall be completed within a second assuming the webpage isn't unreasonably large.
\subsection{Robustness}
Implicitly included within the list of functional test cases since extreme cases as well as boundary cases will be performed.\\\\

\pagebreak

\section{Traceability to Requirements}
\begin{table}[h!]
\centering
\begin{tabular}{| p{2.5cm} | p{8cm} |}   \hline
	Requirement Designation &Associated Requirement\\ \hline
	F1 &Functional requirements 5 and 7.\\ \hline
	F2 &Functional requirements 5 and 7.\\ \hline
	F3 &Functional requirements 3 and 5 \\ \hline
	F4 &Functional requirements 1, 2, 3, 4 and 7 \\ \hline
	F5 &Functional requirements 5 \\ \hline
	F6 &Functional requirements 1, 4, 5 \\ \hline
	F7 &Functional requirements 1 \\ \hline
	U1 &Non-Functional requirements: \\ \hline
	P1 &Non-Functional requirement: Performance\\ \hline
	P2 &Non-Functional requirement: Performance\\ \hline
\end{tabular}
\caption{Traceability to Requirements}
\label{table:Traceability to Requirements}
\end{table}


\section{Testing Summary}
\subsection{Usability Testing }
For our Usability testing we had a few participants execute common actions within the system. We found that while the log-in process was received quite well by all the participants, there was sort of an issue with the command-line interface. For the downloading of the Webcrawler program files, it wasn't hard for the participants. Although they felt the number of files needed to be downloaded for the program was a bit too much and  the initialization of the command line was a bit tedious.
Inputting the option for the web crawler program wasn't deemed as hard by most users.

\subsection{Performance Testing}
We will want to test the number of active users that can be on the system at one time even though each user of the program is independent of the other. We will also want to test the number of active users that can be downloading resources at the same time from the same website. These tests will also be run using the same website on multiple browsers to test compatibility.  To test the performance of a single user, we manually executed tasks that the user normally would.

\subsection{Security}
Security concerns have already been validated. Every user of the program has a different command line interface, no additional security is required. In light of this, we focused on getting feedback in other areas.

\subsection{Response to feedback}
A User Manual will need to be created in order to make learning how to use this program on the command line much easier.
One participant expressed during a task where they were to check for errors that it was slightly difficult. This was due to the user not having the right installations present on the user's system. The solution to this will be in the user manual. Participants were generally pleased with the way the program worked. 

\subsection{Changes Due to Testing}
The interface for saving html links needs some refinement. There were some changes implemented, however more refinement will occur during future versions.


\section{Code Coverage}
\begin{table}[h!]
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{4cm} |}    \hline
Requirement & Positive TC Result &Negative TC Result \\ \hline
Locate Information and related websites& Pass & Pass\\ \hline
Automatically download resources from a web page.&Pass & Pass\\ \hline
View list of status codes from website&Pass & Pass\\ \hline
Specify website to crawl&Pass & Pass\\ \hline
Audit Content on companies website&Pass & Pass\\ \hline
Map website Depth&Pass & Pass\\ \hline
Return website status code&Pass & Pass\\ \hline

\end{tabular}
\caption{Code Coverage}
\label{table:Code Coverage}
\end{table}

We have successfully ran our tests. From the tests we conducted, a  proficient coverage rate has been achieved. A few of our methods have never been called however, it is not crucial that these methods be tested. This report shows that code coverage is satisfactory since the amount of testing necessary depends on a number of factors, and all of those factors have in face been achieved. These factors in the case of this program include algorithmic implementations, use of external libraries and interface robustness. Since all of these factors have been tested thoroughly, there is no need for anymore coverage.




\noindent \wss{This is an example comment.  You can turn comments off by replacing
  commentstrue by commentsfalse.}\\
\hm{Sample comment}\\
\tz{Sample comment}\\
\pl{Sample comment}

\end{document}
